import express from 'express';
import cors from 'cors';
import { MCPClient } from '../mcp-client/build/index.js';

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());

// Armazenar inst√¢ncias de clientes MCP por sess√£o
const mcpClients = new Map();

// Fun√ß√£o para obter ou criar cliente MCP
function getMCPClient(sessionId, apiKey, serverCommand, serverArgs, serverEnvs) {
  const clientKey = `${sessionId}_${apiKey}_${serverCommand}_${serverArgs.join('_')}`;
  
  if (!mcpClients.has(clientKey)) {
    const client = new MCPClient(apiKey);
    mcpClients.set(clientKey, {
      client,
      connected: false,
      serverCommand,
      serverArgs,
      serverEnvs,
      lastActivity: Date.now()
    });
  }
  
  const clientInfo = mcpClients.get(clientKey);
  clientInfo.lastActivity = Date.now();
  
  return clientInfo;
}

// Endpoint principal para executar o agente
app.post('/execute', async (req, res) => {
  try {
    const { 
      prompt, 
      apiKey, 
      mcpServers,
      allServersDiscovery, // Nova propriedade com informa√ß√µes de todos os servidores
      selectedServer,
      serverCommand = 'node', 
      serverArgs = ['../mcp-server-demo/influxdb3_mcp_server/build/index.js'],
      serverEnvs = {},
      sessionId = 'default'
    } = req.body;
    
    if (!prompt) {
      return res.status(400).json({
        success: false,
        error: 'Prompt √© obrigat√≥rio'
      });
    }

    if (!apiKey) {
      return res.status(400).json({
        success: false,
        error: 'API Key da OpenAI √© obrigat√≥ria'
      });
    }

    console.log(`Executando prompt: ${prompt}`);
    if (selectedServer) {
      console.log(`Selected MCP server for execution: ${selectedServer}`);
    }
    console.log(`Comando do servidor: ${serverCommand} ${serverArgs.join(' ')}`);
    
    // Log MCP Servers configuration
    if (mcpServers) {
      console.log('üîç DEBUG - MCP Servers configuration received:');
      console.log('  - mcpServers type:', typeof mcpServers);
      console.log('  - mcpServers keys:', Object.keys(mcpServers || {}));
      
      // Check if it's the new format with mcpServers property
      if (mcpServers.mcpServers) {
        console.log('  - Using new format with mcpServers property');
        console.log('  - Available servers:', Object.keys(mcpServers.mcpServers));
      } else {
        console.log('  - Using legacy format (direct server configuration)');
      }
    }

    // Log All Servers Discovery information
    if (allServersDiscovery) {
      console.log('üîç DEBUG - All Servers Discovery received:');
      console.log('  - allServersDiscovery type:', typeof allServersDiscovery);
      console.log('  - allServersDiscovery keys:', Object.keys(allServersDiscovery || {}));
      
      // Log status of each discovered server
      for (const [serverName, serverInfo] of Object.entries(allServersDiscovery)) {
        const status = serverInfo.available ? '‚úÖ Available' : '‚ùå Unavailable';
        const tools = serverInfo.toolsCount || 0;
        const resources = serverInfo.resourcesCount || 0;
        console.log(`  üìä ${serverName}: ${status} - Tools: ${tools}, Resources: ${resources}`);
      }
      
      // Calculate totals
      const totalServers = Object.keys(allServersDiscovery).length;
      const availableServers = Object.values(allServersDiscovery).filter(info => info.available).length;
      const totalTools = Object.values(allServersDiscovery).reduce((sum, info) => sum + (info.toolsCount || 0), 0);
      const totalResources = Object.values(allServersDiscovery).reduce((sum, info) => sum + (info.resourcesCount || 0), 0);
      
      console.log(`  üìà Summary: ${availableServers}/${totalServers} servers available`);
      console.log(`  üõ†Ô∏è  Total tools across all servers: ${totalTools}`);
      console.log(`  üìö Total resources across all servers: ${totalResources}`);
    }

    // Obter cliente MCP
    const mcpClientInfo = getMCPClient(sessionId, apiKey, serverCommand, serverArgs, serverEnvs);
    
    // üîç DEBUG: Adicionar logs aqui
    console.log('üîç DEBUG - Dados recebidos no mcp-host:');
    console.log('  - serverCommand:', serverCommand);
    console.log('  - serverArgs:', serverArgs);
    console.log('  - serverEnvs:', serverEnvs);
    console.log('  - Tipo serverEnvs:', typeof serverEnvs);
    console.log('  - Chaves serverEnvs:', Object.keys(serverEnvs || {}));
    console.log('  - Valores serverEnvs:', Object.values(serverEnvs || {}));
    
    // Processar serverEnvs se for string
    let serverEnvsObject = serverEnvs;
    if (typeof serverEnvs === 'string' && serverEnvs.trim()) {
        try {
            serverEnvsObject = JSON.parse(serverEnvs);
        } catch (parseError) {
            console.warn('Erro ao fazer parse das vari√°veis de ambiente:', parseError.message);
            serverEnvsObject = {};
        }
    }
    
    console.log('üîç DEBUG - Vari√°veis processadas:');
    console.log('  - serverEnvsObject:', serverEnvsObject);
    console.log('  - Tipo serverEnvsObject:', typeof serverEnvsObject);
    console.log('  - Chaves serverEnvsObject:', Object.keys(serverEnvsObject || {}));
    
    // Conectar a todos os servidores MCP dispon√≠veis para obter todas as ferramentas
    const allMCPClients = {};
    const allTools = [];
    const allResources = [];
    
    console.log('üîó Conectando a todos os servidores MCP dispon√≠veis...');
    
    // Conectar ao servidor selecionado para execu√ß√£o
    if (!mcpClientInfo.connected) {
      try {
        await mcpClientInfo.client.connect(serverCommand, serverArgs, serverEnvsObject);
        mcpClientInfo.connected = true;
        console.log(`‚úÖ Conectado ao servidor de execu√ß√£o: ${selectedServer || 'default'}`);
      } catch (error) {
        console.error('Erro ao conectar ao servidor MCP de execu√ß√£o:', error);
        
        // Tentar reconectar uma vez para servidores remotos (com timeout reduzido)
        if (serverCommand.includes('npx')) {
          console.log('Tentando reconectar ao servidor remoto...');
          try {
            await mcpClientInfo.client.disconnect();
            await new Promise(resolve => setTimeout(resolve, 1000)); // Aguardar 1s (reduzido de 2s)
            await mcpClientInfo.client.connect(serverCommand, serverArgs, serverEnvsObject);
            mcpClientInfo.connected = true;
            console.log('Reconex√£o bem-sucedida');
          } catch (retryError) {
            console.error('Falha na reconex√£o:', retryError);
            return res.status(500).json({
              success: false,
              error: `Erro ao conectar ao servidor MCP de execu√ß√£o: ${retryError.message}`
            });
          }
        } else {
          return res.status(500).json({
            success: false,
            error: `Erro ao conectar ao servidor MCP de execu√ß√£o: ${error.message}`
          });
        }
      }
    }
    
    // Conectar a todos os outros servidores dispon√≠veis para obter suas ferramentas
    if (allServersDiscovery && Object.keys(allServersDiscovery).length > 1) {
      console.log('üîó Conectando aos outros servidores MCP para obter ferramentas...');
      
      for (const [serverName, serverInfo] of Object.entries(allServersDiscovery)) {
        // Pular o servidor j√° conectado para execu√ß√£o
        if (serverName === selectedServer) {
          console.log(`‚è≠Ô∏è  Pulando ${serverName} (j√° conectado para execu√ß√£o)`);
          continue;
        }
        
        // Pular servidores indispon√≠veis
        if (!serverInfo.available) {
          console.log(`‚ùå Pulando ${serverName} (indispon√≠vel: ${serverInfo.error || 'unknown error'})`);
          continue;
        }
        
        try {
          console.log(`üîó Conectando ao servidor: ${serverName}`);
          const serverConfig = serverInfo.config;
          
          // Criar cliente tempor√°rio para este servidor
          const tempClient = new MCPClient({
            name: `temp-${serverName}`,
            version: '1.0.0'
          });
          
          // Conectar ao servidor
          await tempClient.connect(serverConfig.command, serverConfig.args, serverEnvsObject);
          console.log(`‚úÖ Conectado ao servidor: ${serverName}`);
          
          // Obter ferramentas e recursos
          try {
            const tools = await tempClient.listTools();
            const resources = await tempClient.listResources();
            
            console.log(`üõ†Ô∏è  ${serverName}: ${tools.length} ferramentas, ${resources.length} recursos`);
            
            // Adicionar ferramentas e recursos √† lista geral
            allTools.push(...tools.map(tool => ({ ...tool, server: serverName })));
            allResources.push(...resources.map(resource => ({ ...resource, server: serverName })));
            
          } catch (toolError) {
            console.warn(`‚ö†Ô∏è  Erro ao obter ferramentas de ${serverName}: ${toolError.message}`);
          }
          
          // Desconectar do servidor tempor√°rio
          await tempClient.disconnect();
          console.log(`üîå Desconectado do servidor: ${serverName}`);
          
        } catch (connectionError) {
          console.warn(`‚ö†Ô∏è  Erro ao conectar ao servidor ${serverName}: ${connectionError.message}`);
        }
      }
    }
    
    console.log(`üìä Resumo das ferramentas dispon√≠veis:`);
    console.log(`  - Servidor de execu√ß√£o: ${mcpClientInfo.connected ? '‚úÖ Conectado' : '‚ùå Desconectado'}`);
    console.log(`  - Ferramentas adicionais: ${allTools.length}`);
    console.log(`  - Recursos adicionais: ${allResources.length}`);
    console.log(`  - Total de ferramentas: ${allTools.length + (mcpClientInfo.connected ? 3 : 0)}`); // 3 √© o padr√£o do servidor de execu√ß√£o

    // Executar prompt
    console.log('üöÄ Executando prompt com todas as ferramentas dispon√≠veis...');
    const result = await mcpClientInfo.client.executePrompt(prompt);
    
    // Adicionar informa√ß√µes sobre todas as ferramentas dispon√≠veis
    const enhancedResult = {
      ...result,
      allAvailableTools: {
        executionServer: {
          name: selectedServer || 'default',
          toolsCount: result.toolsUsed ? result.toolsUsed.length : 0,
          tools: result.toolsUsed || []
        },
        additionalServers: allTools.map(tool => ({
          server: tool.server,
          tool: tool.name,
          description: tool.description
        })),
        summary: {
          totalServers: 1 + (allTools.length > 0 ? new Set(allTools.map(t => t.server)).size : 0),
          totalTools: (result.toolsUsed ? result.toolsUsed.length : 0) + allTools.length,
          totalResources: allResources.length
        }
      }
    };
    
    console.log('üìä Resultado da execu√ß√£o:');
    console.log(`  - Ferramentas usadas: ${result.toolsUsed ? result.toolsUsed.length : 0}`);
    console.log(`  - Ferramentas adicionais dispon√≠veis: ${allTools.length}`);
    console.log(`  - Total de ferramentas: ${enhancedResult.allAvailableTools.summary.totalTools}`);
    
    res.json(enhancedResult);
  } catch (error) {
    console.error('Erro no endpoint /execute:', error);
    res.status(500).json({
      success: false,
      error: 'Erro interno do servidor'
    });
  }
});

// Endpoint para verificar status
app.get('/health', (req, res) => {
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    activeClients: mcpClients.size
  });
});

// Endpoint para listar ferramentas dispon√≠veis
app.get('/tools', async (req, res) => {
  try {
    const { 
      apiKey, 
      serverCommand = 'node', 
      serverArgs = ['../mcp-server-demo/build/index.js'],
      serverEnvs = {},
      sessionId = 'tools'
    } = req.query;

    if (!apiKey) {
      return res.status(400).json({
        success: false,
        error: 'API Key da OpenAI √© obrigat√≥ria'
      });
    }

    // Processar serverEnvs se for string
    let serverEnvsObject = {};
    if (typeof serverEnvs === 'string' && serverEnvs.trim()) {
      try {
        serverEnvsObject = JSON.parse(serverEnvs);
      } catch (parseError) {
        console.warn('Erro ao fazer parse das vari√°veis de ambiente:', parseError.message);
      }
    } else if (typeof serverEnvs === 'object' && serverEnvs !== null) {
      serverEnvsObject = serverEnvs;
    }

    // Obter cliente MCP
    const mcpClientInfo = getMCPClient(sessionId, apiKey, serverCommand, serverArgs.split(','), serverEnvsObject);
    
    // Conectar se necess√°rio
    if (!mcpClientInfo.connected) {
      await mcpClientInfo.client.connect(serverCommand, serverArgs.split(','), serverEnvsObject);
      mcpClientInfo.connected = true;
    }

    const tools = await mcpClientInfo.client.listTools();

    res.json({
      success: true,
      tools: tools
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Endpoint para testar conex√£o com servidor MCP
app.post('/test-connection', async (req, res) => {
  try {
    const { 
      serverCommand = 'node', 
      serverArgs = ['../mcp-server-demo/influxdb3_mcp_server/build/index.js'],
      serverEnvs = {}
    } = req.body;

    console.log(`üîç Testing connection to MCP server: ${serverCommand} ${serverArgs.join(' ')}`);

    // Criar cliente tempor√°rio para teste
    const testClient = new MCPClient('test-api-key');
    
    try {
      // Tentar conectar com timeout reduzido
      await testClient.connect(serverCommand, serverArgs, serverEnvs);
      
      // Se conectou com sucesso, tentar listar ferramentas
      try {
        const tools = await testClient.listTools();
        const resources = await testClient.listResources();
        
        console.log(`‚úÖ Connection test successful for ${serverCommand}`);
        console.log(`  - Tools available: ${tools.length}`);
        console.log(`  - Resources available: ${resources.length}`);
        
        res.json({
          success: true,
          message: 'Connection test successful',
          toolsCount: tools.length,
          resourcesCount: resources.length,
          serverCommand,
          serverArgs
        });
      } catch (capabilityError) {
        console.log(`‚ö†Ô∏è Connected but capability discovery failed: ${capabilityError.message}`);
        
        // Para servidores que n√£o implementam m√©todos MCP padr√£o,
        // ainda consideramos v√°lidos se conseguirem conectar
        res.json({
          success: true,
          message: 'Connected but capability discovery failed',
          warning: capabilityError.message,
          toolsCount: 0,
          resourcesCount: 0,
          serverCommand,
          serverArgs,
          // Marcar como servidor v√°lido mesmo sem capacidades MCP
          validForExecution: true
        });
      }
      
      // Desconectar cliente de teste
      await testClient.disconnect();
      
    } catch (connectionError) {
      console.log(`‚ùå Connection test failed: ${connectionError.message}`);
      res.status(500).json({
        success: false,
        error: 'Connection test failed',
        details: connectionError.message,
        serverCommand,
        serverArgs
      });
    }
    
  } catch (error) {
    console.error('Error in connection test:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error during connection test',
      details: error.message
    });
  }
});

// Endpoint para desconectar um cliente espec√≠fico
app.post('/disconnect', async (req, res) => {
  try {
    const { sessionId = 'default' } = req.body;
    
    // Encontrar e desconectar clientes da sess√£o
    const clientsToDisconnect = [];
    for (const [key, clientInfo] of mcpClients.entries()) {
      if (key.startsWith(sessionId + '_')) {
        clientsToDisconnect.push(key);
      }
    }

    for (const key of clientsToDisconnect) {
      const clientInfo = mcpClients.get(key);
      if (clientInfo.connected) {
        await clientInfo.client.disconnect();
      }
      mcpClients.delete(key);
    }

    res.json({
      success: true,
      disconnectedClients: clientsToDisconnect.length
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Cleanup ao encerrar o processo
process.on('SIGINT', async () => {
  console.log('Encerrando servidor e desconectando clientes MCP...');
  
  for (const [key, clientInfo] of mcpClients.entries()) {
    if (clientInfo.connected) {
      try {
        await clientInfo.client.disconnect();
      } catch (error) {
        console.error(`Erro ao desconectar cliente ${key}:`, error);
      }
    }
  }
  
  process.exit(0);
});

// Limpeza autom√°tica de sess√µes antigas (a cada 5 minutos)
setInterval(() => {
  const now = Date.now();
  const maxAge = 10 * 60 * 1000; // 10 minutos
  
  for (const [key, clientInfo] of mcpClients.entries()) {
    if (now - clientInfo.lastActivity > maxAge) {
      console.log(`Removendo sess√£o antiga: ${key}`);
      try {
        clientInfo.client.disconnect();
      } catch (error) {
        console.error('Erro ao desconectar cliente antigo:', error);
      }
      mcpClients.delete(key);
    }
  }
}, 5 * 60 * 1000); // Executar a cada 5 minutos

app.listen(PORT, '0.0.0.0', () => {
  console.log(`MCP Host rodando na porta ${PORT}`);
});

